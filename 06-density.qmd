# Density-based methods {#sec-density-methods}

```{r}
#| include: false
#| cache: false
source("before-each-chapter.R")
wine_reviews <- fetch_wine_reviews() |> cache("wine_reviews")
```

Anomalies are observations that are unlikely to have come from the same distribution as the rest of the data. One method to identify anomalies is to first estimate the probability distribution of the data, and then find observations that are improbable under that distribution. This is the approach taken by density-based methods, where anomalies are defined as observations with low probability.

Any density-based method of anomaly detection first requires that we have a density estimate at each observation, which we will denote by $f(\bm{y}_i)$. This may be an assumed density, or estimated from the data; it may be a parametric function, or a nonparametric estimate; it may be a conditional density or a marginal density. Wherever it comes from, we will treat $f$ as an appropriate probability density function for the data set. When $\bm{y}_i$ takes values on a discrete space (such as the integers), then $f$ is a probability mass function, but we will call it a "density" for convenience when discussing methods that can apply to both discrete and continuous data. In many cases, $f(\bm{y}_i)$ is the estimated *likelihood* of the observation from a given model.

## Surprisals {#sec-surprisals}

"Surprisal" is a term coined by American engineer Myron @Tribus1961 in the context of information theory. In the statistical literature it is better known as a "log score". But since we are considering anomaly detection, "surprisal" seems a more appropriate word to use here.

The surprisal of an observation $\bm{y}_i$, is defined as
$$
  s_i = -\log f(\bm{y}_i),
$$ {#eq-surprisal}
measuring the surprise in seeing the observation. So it is a measure of how anomalous (or surprising) that observation is, given the density $f$. A large value of $s_i$ indicates that $\bm{y}_i$ is not a likely value, and so is a potential anomaly. On the other hand, typical values will have low surprisals. In information theory, the average surprisal is known as the entropy of a random variable [@Cover2006;@Stone2022], and provides a measure of uncertainty.

Although the term "surprisal" may not be in common use amongst statisticians and other data scientists, the underlying idea is widely used. For example, if $f$ is obtained from a model with parameters that need to be estimated from the data, then the sum of the surprisals is equal to minus the log likelihood of the data. Therefore, finding parameters that minimize the sum of the surprisals is equivalent to maximum likelihood estimation.

Surprisals are also commonly used in forecasting and prediction problems (where they are called log scores) to assess whether an estimated distribution $f$ provides a good description of the future data values $y$ [@Gneiting2014]. In that context, the data are thought to be a reliable reflection of the underlying processes, and once the data are observed, the surprisal is used to assess how well the estimated distribution $f$ matches what actually happened. In this book, we are using surprisals in reverse --- we assume $f$ is a good description of the underlying processes, and then we use the surprisals to identify observations that are unlikely to have come from that distribution.

Let's look at some specific examples.

### Normal distribution
Suppose our observations come from a N(0,1) distribution, and that $f$ denotes the corresponding density function. Then
$$
  s_i = - \log\left(\frac{1}{\sqrt{2\pi}} e^{-y_i^2/2}\right)
      = \frac12 y_i^2 + \frac12\log(2\pi).
$$
So the surprisals are simply equal to half the squared observations plus a constant. This is easily extended to any normal distribution, showing that surprisals are equal to half the squared *scaled* observations plus a constant.

### $\chi^2$ distribution

Similarly, for a $\chi^2_k$ distribution, a surprisal is given by
$$
  s_i = -\log\left(\frac{y_i^{k/2-1}e^{-y_i/2}}{2^{k/2}\Gamma(k/2)}\right)
      = \frac{1}{2} y_i - (k/2-1)\log(y_i) + c_k
$$
where $c_k$ is a constant.

### Poisson distribution

Surprisals can also be computed for discrete distributions. For a Poisson($\lambda$) distribution, a surprisal is given by
$$
  s_i = -\log\left(\frac{\lambda^{y_i} e^{-\lambda}}{y_i!}\right)
  = \log(y_i!) - y_i\log(\lambda) + \lambda
$$

### Multivariate standard normal distribution

The definition of a surprisal also works for multivariate distributions. For a $m$-dimensional N$(\bm{0}, \bm{\Sigma})$ distribution, a surprisal is given by
$$
s_i = -\log\left(
 (2\pi)^{-m/2}|\bm{\Sigma}|^{-1/2} \exp\Big\{-\frac{1}{2}\bm{y}_i'\bm{\Sigma}^{-1}\bm{y}\Big\} \right) =
\frac{1}{2} \bm{y}_i'\bm{\Sigma}^{-1}\bm{y}_i + \frac{m}{2}\log(2\pi) + \frac{1}{2} \log|\bm{\Sigma}|
$$
When $\bm{\Sigma} = \bm{I}$, this is simply the sum of surprisals computed on each of the marginal distributions.

## Surprisal probabilities {#sec-surprisal-probabilities}

We can use surprisals to compute the probability of an observation being at least as anomalous as $\bm{y}_i$ under the distribution $f$:
$$
p_i = \int f(\bm{u}) ùüô(-\log f(\bm{u}) > s_i) d\bm{u} = \int f(\bm{u}) ùüô(f(\bm{u}) < f(y_i)) d\bm{u},
$$ {#eq-pi-density}
where $ùüô(z)$ is an indicator function taking value 1 when $z$ is true and 0 otherwise.

@fig-density-scores shows the calculation for a $\chi^2_5$ distribution.

```{r}
#| label: fig-density-scores
#| fig-cap: "Top: Density with one observation shown at $y_i$. The shaded area shows the area where $f(y) < f(y_i)$, corresponding to $p_i$. In this example, $p_i = 0.1$, so the region between the orange shaded segments is a 90% HDR. Middle: surprisals for different values of $y$. Bottom: surprisal probabilities for different values of $y$."#|
#| fig-asp: 1.3
#| out-width: "80%"
#| echo: false
den <- dist_chisq(5)
hdr <- hdr(den, size = 90) |> unlist() %>% `[`(c("lower", "upper"))
falpha <- density(den, at = hdr["lower"])
df <- tibble(
  y = seq(0, 15, l = 501),
  fy = density(den, at = y)[[1]],
  s = -log(fy),
  p = surprisals_prob(y, distribution = den)
)
palpha <- 0.1
p1 <- df |>
  ggplot(aes(x = y, y = fy)) +
  geom_line() +
  labs(x = "y", y = "Probability Density Function: f(y)") +
  geom_hline(aes(yintercept = falpha), col = "#D55E00", linetype = "dashed") +
  geom_polygon(
    fill = "#D55E00",
    data = df |>
      filter(y >= hdr[2]) |>
      bind_rows(
        tibble(y = c(hdr[2], hdr[2], max(df$y)), fy = c(0, falpha, 0))
      ) |>
      arrange(fy, y)
  ) +
  geom_polygon(
    fill = "#D55E00",
    data = df |>
      filter(y <= hdr["lower"]) |>
      bind_rows(
        tibble(y = c(hdr[1], hdr[1], 0), fy = c(0, falpha, 0))
      ) |>
      arrange(fy, desc(y))
  ) +
  scale_x_continuous(
    breaks = c(seq(0, 15, by = 5), hdr[2]),
    labels = latex2exp::TeX(c(seq(0, 15, by = 5), "$y_i$")),
    minor_breaks = NULL
  ) +
  scale_y_continuous(
    breaks = c(seq(0, 0.15, by = 0.05), falpha),
    labels = latex2exp::TeX(c(seq(0, 15, by = 5), "$f(y_i)$")),
    minor_breaks = NULL
  )
p2 <- df |>
  ggplot(aes(x = y, y = s)) +
  geom_line() +
  labs(x = "y", y = "Surprisal: -log f(y)") +
  geom_hline(aes(yintercept = -log(falpha)), col = "#D55E00", linetype = "dashed") +
  geom_line(
    data = tibble(x = rep(hdr[2], 2), y = c(0, -log(falpha))),
    aes(x = x, y = y), col = "#D55E00", linetype = "dashed"
  ) +
  scale_x_continuous(
    breaks = c(seq(0, 15, by = 5), hdr[2]),
    labels = latex2exp::TeX(c(seq(0, 15, by = 5), "$y_i$")),
    minor_breaks = NULL
  ) +
  scale_y_continuous(
    breaks = c(seq(0, 7, by = 2), -log(falpha)),
    labels = latex2exp::TeX(c(seq(0, 7, by = 2), "$s_i$")),
    minor_breaks = NULL
  )
p3 <- df |>
  ggplot(aes(x = y, y = p)) +
  geom_line() +
  labs(x = "y", y = "Surprisal Probability: p") +
  geom_hline(aes(yintercept = palpha), col = "#D55E00", linetype = "dashed") +
  geom_line(
    data = tibble(x = rep(hdr[2], 2), y = c(0, palpha)),
    aes(x = x, y = y), col = "#D55E00", linetype = "dashed"
  ) +
  scale_x_continuous(
    breaks = c(seq(0, 15, by = 5), hdr[2]),
    labels = latex2exp::TeX(c(seq(0, 15, by = 5), "$y_i$")),
    minor_breaks = NULL
  ) +
  scale_y_continuous(
    breaks = c(seq(0, 1, by = .2), palpha),
    labels = latex2exp::TeX(c(seq(0, 1, by = .2), "$p_i$")),
    minor_breaks = NULL
  )
patchwork::wrap_plots(p1, p2, p3, ncol = 1)
```

The `surprisals()` function takes values of the data $\bm{y}_i$ and returns values of $s_i$, where the assumed density $f$ can be provided as a distribution object from the `distributional` package. The values of $p_i$ can be obtained using `surprisals_prob()`. 

```{r}
#| label: surprisals_eg
#| code-fold: false
tibble(
  y = -5:5,
  s = surprisals(y, distribution = dist_normal()),
  p = surprisals_prob(y, distribution = dist_normal())
)
```

The value of $p_i$ is the probability of an observation being at least as anomalous as $\bm{y}_i$‚Äã if the observations come from the distribution $f$. So if we label points as anomalous when $p_i < \alpha$, we will have a false positive rate of $\alpha$.

### Connection to Highest density regions

Surprisal probabilities are related to highest density regions discussed in @sec-hdr and @sec-mhdr. If $\bm{y}_i$ lies on the boundary of the $100(1-\alpha)\%$ highest density region, then $p_i = 1-\alpha$. This should be clear by comparing @eq-pi-density with @eq-mhdr.

### Connection to $z$-scores

For any symmetric univariate distribution, $p_i = 2[1 - F(c+|y_i-c|)]$, where $F$ is the corresponding distribution function centered at $c$. Therefore, under the Normal distribution $N(\mu, \sigma^2)$, $p_i = 2[1-\Phi(|y_i-\mu|/\sigma)]$, where $\Phi$ is the standard Normal distribution function.

This shows that when $f$ is a Normal density, identifying anomalies as observations with $p_i < \alpha$ is equivalent to a z-score test (@sec-zscores) with the threshold set to the $1-\alpha/2$ quantile of the standard Normal distribution.

### LOO surprisals

If the density $f$ has been estimated from the data, then there is a problem of circular reasoning. Any genuine anomalies may affect the estimated density, and then they may not appear to be anomalies. Therefore, it is sometimes useful to consider the leave-one-out (LOO) estimate given by $f_{-i}$. That is, $f_{-i}$ is the density estimate using all observations other than the $i$th observation. Then an unusual observation can't influence the density estimate, giving us a better measure of how anomalous it really is. In this case, we will call the associated surprisal, a "LOO surprisal", given by $s_i = -\log f_{-i}(\bm{y}_i)$.

### Approximate GPD surprisal probabilities {#sec-gpd-tails}

If we do not know what the distribution of the data should be, or if we think our assumed distribution is incorrect for some reason, there are some ways to find approximate surprisal probabilities that are still accurate even when the assumed distribution is not.

Let $f^*$ denote the assumed (and possibly incorrect) density function. It might be a poor estimate of the true density, or it might just be a density on the same sample space as the data. Using this assumed density, we can compute the surprisals, $s_i = -\log f^*(\bm{y}_i)$.

Then we can fit a Generalized Pareto Distribution (GPD) to the largest surprisals using the POT approach discussed in @sec-evt. Even when $f^*$ is incorrect or poorly estimated, the extreme surprisals will still follow a Generalized Pareto Distribution.

Let $\beta$ denote the tail probability used in the GPD threshold, and let $u$ denote the $1-\beta$ sample quantile of the surprisal values. For example, $\beta = 0.1$ is a common choice, and then $u$ is the $90^{\text{th}}$ percentile of the $s_i$ values. We estimate a GPD distribution using the surprisals above $u$, and then compute the approximate surprisal probability of each observation with $s_i>u$ by
$$
\hat{p}_i = \beta\int_{s_i}^\infty \hat g(s) ds,
$$ {#eq-pi-gpd}
where $\hat g()$ denotes the estimated GPD density function. This approximation only gives us surprisal probabilities for the surprisals above the threshold $u$. For any $s_i \le u$, all we can say is that $\hat{p}_i \ge \beta$.

::: {.callout-important}
# Need some theory here
What can we say about the quality of the approximation for those surprisals above $u$?

Is it true that the FTG theorem holds for all surprisal values, or do we need conditions on $f$?

e.g., if the surprisal ranks under $f$ and $f^*$ are equal, I think this should work ok. That should be true for any distribution where $u$ is greater than the largest mode of $f$.
:::

The approach does require a relatively large number of surprisals to be available, in order to adequately estimate the GPD from the top $\beta$ of the observations. So we would normally need at least a few hundred observations to start with.

The `surprisals_prob()` function has an approximation argument for specifying if we want to use the GPD approximation in computing surprisal probabilities. The argument `threshold_probability` is used to specify $\beta$, with the default value of 0.1.

### Approximate empirical surprisal probabilities

An alternative approach that does not require a GPD is to estimate $p_i$ as the proportion of surprisals larger than $s_i$. For large $n$, this provides a quick and convenient estimate of $p_i$ that is accurate even when the assumed distribution $f^*$ is not. Suppose $f$ is the true (unknown) density, and $f^*$ is the assumed (possibly incorrect) density. This approach can work well for moderate values of $p_i$, but we need a large number of available surprisals in order to estimate small values of $p_i$.


::: {.callout-important}
# Need some theory here
What can we say about the quality of the approximation?

If the surprisal ranks under $f$ and $f^*$ are equal, this is obviously ok. That should be true in the tails of any distribution --- i.e., when $y_i$ is greater than the largest mode of $f$, or less than the smallest mode of $f$.

Can we say anything else?
:::

The approximation argument of `surprisals_prob()` can also be used to specify if we want to use the empirical surprisal probabilities.

### Example: Standard normal values

For example, consider the 1000 values contained in the first column of `n01`. These were generated from a standard Normal distribution. We can use `surprisals_prob()` to identify anomalies with probability less than 1%. This is equivalent to z-scores greater than `r sprintf("%.3f", qnorm(1-0.01/2))` in absolute value.

We will use all three methods described above, first using the correct density in computing the surprisals, and then repeating the calculation using an incorrect density. For the incorrect density, we will use a $t_3$ distribution, which has much longer tails than the true $N(0,1)$ distribution.

```{r}
#| label: surprisal_prob
#| code-fold: false
# Compute surprisal probabilities of v1 assuming a standard Normal distribution
# and a t4 distribution
norm_prob <- tibble(
  y = n01$v1,
  p =      surprisals_prob(y, distribution = dist_normal()),
  p_gpd =  surprisals_prob(y, distribution = dist_normal(), approximation = "gpd"),
  p_emp =  surprisals_prob(y, distribution = dist_normal(), approximation = "empirical"),
  pt =     surprisals_prob(y, distribution = dist_student_t(4)),
  pt_gpd = surprisals_prob(y, distribution = dist_student_t(4), approximation = "gpd"),
  pt_emp = surprisals_prob(y, distribution = dist_student_t(4), approximation = "empirical")
)
norm_prob |> arrange(p)
```

The most accurate values are in column `p`, as this uses the correct distribution applied to the correct surprisals. Notice that `p_gpd` and `p_emp` are both relatively accurate: the GPD and empirical approximations work. For the probabilities calculated using the incorrect distribution, `pt` is relatively inaccurate, with much larger probabilities than they should be, especially in the extreme tails. But `pt_gpd` and `pt_emp` are both reasonable estimates, despite being based on an incorrect distribution for computing the surprisals. In fact, `p_emp` and `pt_emp` are identical, because the ordering of the surprisals is unchanged despite the incorrect distribution being used.

The various estimates are displayed in @fig-surprisal_prob for values of $y$ greater than 2.5, showing how the estimates (other than `pt`) are particularly accurate in the extreme tails, where we need them for anomaly detection.

```{r}
#| label: fig-surprisal_prob
#| fig-cap: Surprisal probabilities estimated using the correct N(0,1) distribution and using an incorrect $t_4$ distribution. The GPD and empirical estimates of surprisal probabilities are still accurate, even when the wrong distribution is used to compute the surprisal values.
norm_prob |>
  filter(y > 2.5) |>
  tidyr::pivot_longer(p:pt_emp, names_to = "Estimate", values_to = "Probability") |>
  ggplot(aes(x = y, y = Probability, col = Estimate)) +
  geom_line()
```

In summary, even when we don't know the distribution of the data, we can use some
incorrect assumed distribution to compute the surprisals, and then apply either a GPD or the empirical distribution to obtain good estimates of the surprisal probabilities.

## Linear regression surprisals {#sec-regression-log-scores}

Suppose we want to find anomalies amongst $n$ univariate observations $y_1,\dots,y_n$, and we have $p$ variables that we think might be useful for predicting $y$. Then we can write the conditional density as $f(y \mid \bm{x})$, where $\bm{x}$ is a $p$-dimensional vector of predictor variables. Anomalies in $y$ are identified as observations that are unlikely to have come from the conditional density $f$. This is commonly called a "regression model", regardless of the form of $f$, or whether the relationship with $\bm{x}$ is linear or not.

By far the most common type of regression model assumes that $f$ is a Normal distribution, and that the conditional mean is a linear function of $\bm{x}$. Note that this does *not* mean that $y$ is Normally distributed, or that $\bm{x}$ has a Normal distribution. The assumption is that the *conditional* distribution of $y$ given $\bm{x}$ is Normal, which can easily be checked by looking at the residuals from the regression model.

For a linear Normal regression model, with independent observations and homoscedastic errors, the conditional distribution is given by
$$
  y \mid \bm{x} \sim N(\bm{x}_+'\bm{\beta}, \sigma^2),
$$ {#eq-gaussian-regression}
where $\bm{x}_+ = [1, \bm{x}]'$ is a $(p+1)$-dimensional vector containing a 1 in the first position and the predictors in the remaining positions, and $\bm{\beta}$ is a $(p+1)$-dimensional vector of regression coefficients.

### Model estimation

The model can be written in matrix form as
$$
  \bm{y} \sim N(\bm{X}\bm{\beta}, \sigma^2\bm{I}),
$$
where $\bm{X}$ is an $n\times(p+1)$ matrix with the first column being a vector of 1s, and the other columns containing the predictor variables, or equivalently as
$$
  \bm{\varepsilon} = \bm{y} - \bm{X}\bm{\beta} \sim N(\bm{0}, \sigma^2\bm{I}).
$$ {#eq-error-distribution}
Provided $\bm{X}$ is of rank $p+1$, and the errors $\bm{\varepsilon}$ are independent of $\bm{X}$, the model can be estimated using ordinary least squares regression [@seberlee2003], resulting in the estimate
$$
  \hat{\bm{\beta}} = (\bm{X}'\bm{X})^{-1}\bm{X}'\bm{y}.
$$
The fitted values (i.e., predicted values for the training data) are given by
$$
  \hat{\bm{y}} = \bm{X}\hat{\bm{\beta}} = \bm{H}\bm{y},
$$
where $\bm{H} = \bm{X}(\bm{X}'\bm{X})^{-1}\bm{X}'$ is known as the "hat"-matrix because it creates the "y-hat" values $\hat{\bm{y}}$ from the data $\bm{y}$.

The diagonals of $\bm{H}$, given by $h_1,\dots,h_n$, take values between 0 and 1. These are known as the "leverage" values [@faraway2004linear, p69], and measure how much each observation influences the corresponding fitted value. High leverage values (close to 1) correspond to observations that have a large influence on the estimated coefficients, and so leaving those observations out will lead to very different values for the fitted values and residuals. On the other hand, small leverage values (close to 0) correspond to observations that have little influence on the estimated coefficients, and so leaving those observations out will lead to similar values for the fitted values and residuals.

### Residuals

The residuals from the model are given by
$$
  \bm{e} = \bm{y} - \hat{\bm{y}} = (\bm{I} - \bm{H})\bm{y}.
$$ {#eq-residual-distribution}
Note that the residuals have the distribution $\bm{e}\mid\bm{X} \sim N(\bm{0}, \sigma^2(\bm{I} - \bm{H}))$, which is not quite the same as the distribution of the errors given by @eq-error-distribution. However, as $n\rightarrow\infty$, $\bm{H}\rightarrow\bm{I}$, so the two distributions are asymptotically equivalent. Often, we need standardized residuals, which are obtained by dividing each residual by its estimated standard deviation, giving
$$ r_i = \frac{e_i}{\hat{\sigma}\sqrt{1-h_i}}, \qquad i = 1,\dots, n,
$$
where
$$
\hat\sigma^2 = \frac{1}{n-p-1}\sum_{i=1}^n e_i^2
$$ {#eq-residual-variance}
is the estimated residual variance.

A linear model can be estimated in R using the `stats::lm()` function. The `broom::augment()` function will compute the residuals (named `.resid`), the standardized residuals (named `.std.resid`), and the leverage values (names `.hat`).

The surprisals under the Gaussian linear regression model [@eq-gaussian-regression] can be estimated using these standardized residuals, giving
$$
  s_i = -\log\phi(r_i),
$$ {#eq-regression-log-score}
where $\phi(u) = (2\pi)^{-1/2}e^{-u^2}$ is the standard normal density. This can be computed as follows, assuming that `fit` is the output from `stats::lm()`.

```r
broom::augment(fit) |>
  mutate(surprisals = -dnorm(.std.resid, log = TRUE))
```

Equivalently, the `surprisals()` function will compute them:

```r
surprisals(fit)
```

### LOO residuals

The leave-one-out residual for the $i$th observation is defined as the difference between $\bm{y}_i$ and the predicted value obtained using a model fitted to all observations except the $i$th observation. In this context, LOO residuals are often called PRESS (prediction error sum of squares) residuals. At first, it appears that calculating LOO residuals involves a lot of computation --- estimating $n$ separate models. However, the leave-one-out residuals are easily obtained without actually having to re-estimate the model many times. It can be shown [@Montgomery2012, Appendix C.7] that the leave-one-out (LOO) residuals are given by
$$
  e_{-i} = e_{i}/(1-h_{i}),
$$ {#eq-loo-residuals}
where $e_{i}$ is the residual obtained from fitting the model to *all* observations.

The variance of $e_{-i}$ is given by
$$
  \frac{\text{Var}(e_i)}{(1-h_i)^2} = \frac{\sigma^2}{1-h_i},
$$
so we can standardize each LOO residual to obtain
$$
 \frac{e_i / (1-h_i)}{\sigma/\sqrt{1-h_i}} = \frac{e_i}{\sigma \sqrt{1-h_i}}
$$
To avoid any anomalies affecting the estimate of $\sigma$, we consider again the leave-one-out models. If we leave out the $i$th observation, and fit a regression model to the remaining observations, then the estimated variance of the residuals is given by [@Montgomery2012, Appendix C.8]
$$
  \hat\sigma_{-i}^2 = \frac{1}{n-p-2}\left[(n-p-1)\hat\sigma^2 - e_{i}^2/(1-h_i)\right],
$$ {#eq-loo-residual-variance}
where $\hat\sigma^2$ is given by @eq-residual-variance. These are computed by `broom::augment()` and are returned in the column `.sigma`.
Thus the standardized LOO residuals (also known as "externally studentized residuals") are given by
$$
 r_{-i} = \frac{e_i}{\hat\sigma_{-i} \sqrt{1-h_i}}.
$$
Finally, the LOO regression surprisals are given by
$$
  s_{-i} = -\log \phi(r_{-i})
$$ {#eq-log-loo-regression-scores}

If `fit` is the output from `stats::lm()`, then these quantities can be computed as follows.

```r
broom::augment(fit) |>
  mutate(
    std_loo_res = .resid / (.sigma * sqrt(1 - .hat)),
    loo_surprisals = -log(dnorm(std_loo_res, log = TRUE))
  )
```

More simply, we can just use the `surprisals()` function again:

```r
surprisals(fit, loo = TRUE)
```

### Example: Shiraz reviews

For example, consider the wine reviews of Shiraz (aka Syrah), plotted in @fig-shiraz. We can fit a linear regression model to these data to obtain a conditional density estimate of price given the points awarded to each wine. Then, $\bm{X}$ contains just two columns: a column of 1s, and a column containing the points values. The vector $\bm{y}$ contains the log prices of the wines. The model can be fitted as follows.

```{r}
#| label: shiraz-data
#| eval: false
#| code-fold: false
wine_reviews <- fetch_wine_reviews()
```

```{r}
#| label: shiraz-regression
#| code-fold: false
shiraz <- wine_reviews |> filter(variety %in% c("Shiraz", "Syrah"))
fit_wine <- lm(log(price) ~ points, data = shiraz)
summary(fit_wine)
```

The fitted model can be written as
$$
  \log(\text{Price}) \sim N(`r sprintf("%.3f",coef(fit_wine)[1])` + `r sprintf("%.3f",coef(fit_wine)[2])` \times \text{Points}, `r sprintf("%.3f",sigma(fit_wine))`^2),
$$
and is depicted in @fig-shiraz-regression with 95% prediction intervals.

```{r}
#| label: fig-shiraz-regression
#| warning: false
#| fig.cap: Log price of Shiraz as a function of points, with 95% prediction intervals. The points are horizontally jitted to reduce overplotting. Points outside the prediction intervals are colored.
wine_aug <- broom::augment(fit_wine, data = shiraz, interval = "prediction") |>
  mutate(
    lwr = exp(.lower),
    upr = exp(.upper),
    location = case_when(
      price < lwr ~ "below",
      price > upr ~ "above",
      TRUE ~ "within"
    )
  )
wine_aug |>
  ggplot(aes(y = price, x = points, col = location)) +
  geom_jitter(height = 0, width = 0.1, alpha = 0.5) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "#cccccc", alpha = 0.25) +
  geom_line(aes(y = exp(.fitted)), color = "#666666") +
  scale_y_log10() +
  guides(fill = "none", col = "none") +
  scale_color_manual(values = c("#0072B2", "#D55E00", "#AAAAAA"))
```

The LOO surprisals obtained from this model are shown in @fig-shiraz-regression-scores, using the same colors as @fig-shiraz-regression to indicate whether the observation is below, within, or above, the 95% prediction interval.

```{r}
#| label: fig-shiraz-regression-scores
#| fig.cap: Residuals and surprisals for the Shiraz data using a linear regression model. Points are colored to match the 95% prediction intervals in @fig-shiraz-regression.
#| fig.height: 6
#| fig.asp: 0.8
wine_aug <- wine_aug |>
  mutate(
    std_loo_res = .resid / (.sigma * sqrt(1 - .hat)),
    surprisals = -dnorm(.std.resid, log = TRUE),
    loo_surprisals = -dnorm(std_loo_res, log = TRUE)
  )
wine_aug |>
  select(points, std_loo_res, loo_surprisals, location) |>
  tidyr::pivot_longer(c(std_loo_res, loo_surprisals), names_to = "variable", values_to = "value") |>
  mutate(variable = factor(variable,
    levels = c("std_loo_res", "loo_surprisals"),
    label = c("Standardized LOO residuals", "LOO surprisals")
  )) |>
  ggplot(aes(x = points, y = value, col = location)) +
  facet_grid(variable ~ ., scales = "free_y") +
  geom_jitter(height = 0, width = 0.1, alpha = 0.5) +
  geom_hline(yintercept = 0, color = "#666666") +
  labs(x = "Points", y = "") +
  guides(fill = "none", col = "none") +
  scale_color_manual(values = c("#0072B2", "#D55E00", "#AAAAAA"))
```

```{r}
#| label: shiraz-regression-scores
#| include: false
most_anomalous <- wine_aug |>
  filter(loo_surprisals > 17)
underpriced <- wine_aug |>
  filter(std_loo_res == min(std_loo_res))
good_buy <- wine_aug |>
  filter(points > 95) |>
  filter(std_loo_res == min(std_loo_res))
```

The over-priced wines under this model are shown in blue, while the under-priced wines are shown in orange. This shows that the most anomalous observations are the two with LOO surprisals above 17, and studentized residuals close to 6. The largest LOO surprisal is for the most over-priced wine (under this model), a 2009 Shiraz from the Henschke winery in the Eden Valley region of South Australia, with `r most_anomalous$points[1]` points and a price of $`r most_anomalous$price[1]`.

```{r}
#| code-fold: false
wine_aug |>
  filter(loo_surprisals == max(loo_surprisals)) |>
  select(country:winery, year, points, price, std_loo_res, loo_surprisals)
```

The largest LOO surprisal corresponding to an under-priced wine is for the wine with the lowest residual value, with `r underpriced$points[1]` points and a price of $`r underpriced$price[1]`. Another good buy, at the higher quality end, is the 2007 Syrah from the Rulo winery in the Columbia Valley in Washington State, USA:

```{r}
#| code-fold: false
wine_aug |>
  filter(points > 95) |>
  filter(std_loo_res == min(std_loo_res)) |>
  select(country:winery, year, points:price, std_loo_res, loo_surprisals)
```

This corresponds to the only orange point in @fig-shiraz-regression that has a point value above 95 and a price below the 95% prediction interval.

### Surprisal probabilities

We will compute the surprisal probabilities using the empirical approximation.

```{r}
#| code-fold: false
wine_aug |>
  mutate(prob = rank(-loo_surprisals) / NROW(wine_aug)) |>
  select(country:winery, year, points, price, loo_surprisals, prob) |>
  arrange(prob)
```

Those with the ten smallest surprisal probabilities are all wines that appear to be over-priced given their points values.

The preceding analysis shows the calculations of surprisal probabilities in detail. They can be more simply computed using `surprisals_prob()` as follows.

```{r}
#| code-fold: false
shiraz <- shiraz |>
  mutate(prob = surprisals_prob(fit_wine, loo = TRUE, approximation = "empirical"))
shiraz |>
  select(country:winery, year, points, price, prob) |>
  arrange(prob)
```

@fig-shiraz-surprisal shows the relationship between points and price, with the points colored according to the surprisal probability. The eight blue points are observations with surprisal probabilities less than 0.002.

```{r}
#| label: fig-shiraz-surprisal
#| fig.cap: Price vs points for Shiraz wines. Points are colored according to the surprisal probability. The eight blue points are observations with surprisal probabilities less than 0.002.
shiraz |>
  ggplot(aes(x = points, y = price, color = prob < 0.002)) +
  geom_jitter(height = 0, width = 0.2) +
  scale_y_log10()
```

```{r}
#| include: false
#| label: shiraz-check
shiraz_surprise <- shiraz |> filter(prob < 0.002)
if(NROW(shiraz_surprise) != 8L)
  stop("Something is wrong here.")
```

## GAM surprisals

In some applications, it is not appropriate to assume the conditional density is Gaussian, or that the relationships are linear. One useful model that allows for non-Gaussian densities, and non-linear relationships, is a generalized additive model or GAM. Under this model, the conditional density is given by [@Wood2017gam]
$$
  y\mid\bm{x} \sim f(\mu), \qquad \ell(\mu) = \sum_{k=1}^p g_k(x_{k}),
$$
where $\mu = \text{E}(y | \bm{x})$ denotes the conditional mean, $\ell()$ is a link function, and each $g_k$ function is smooth. If $f$ is Normal, $\ell$ is the identity, and $g_i(u) = \beta_i u$, then this reduces to the linear Gaussian model (@eq-gaussian-regression).

```{r}
#| include: false
df_no <- cricket_batting |>
  filter(Innings > 0) |>
  mutate(prop_no = NotOuts / Innings)
p <- sum(df_no$NotOuts) / sum(df_no$Innings)
```

Consider the number of "not outs" for each batter in the `cricket_batting` data set. A "not out" occurs when a batsman has not been dismissed at the end of the team's innings. Let's consider if there are some batters who have an unusually high proportion of not outs. The data set contains results from `r sum(df_no$Innings)` innings, of which `r sum(df_no$NotOuts)` were not outs. So the overall proportion of not outs is $`r sum(df_no[["NotOuts"]])` / `r sum(df_no[["Innings"]])` = `r sprintf("%.3f", p)`$.

@fig-notouts shows the proportion of not outs for each batter as a function of the number of innings they played. The unusual patterns on the left of each plot is due to the discrete nature of the data --- both the number of not outs and the number of innings must be integers. There is some overplotting that occurs due to batters having the same numbers of not-outs and innings, which results in the higher color density of the corresponding plotted points. Batters who have played only a few innings tend to have a higher proportion of not outs on average, and a higher variance, than those who have played a large number of innings.

```{r}
#| label: fig-notouts
#| fig.cap: "Proportion of not outs for each batter as a function of the number of innings they played."
#| message: false
#| code-fold: false
df_no <- cricket_batting |>
  filter(Innings > 0) |>
  mutate(prop_no = NotOuts / Innings)
df_no |>
  ggplot(aes(x = Innings, y = NotOuts / Innings)) +
  geom_point(alpha = 0.15)
```

This suggests that we can construct a GAM for the number of not outs for each batter as a function of the number of innings they played. It is natural to use a Binomial distribution with a logit link function:
$$
  \text{NotOuts} \mid \text{Innings} \sim \text{Binomial}(n=\text{Innings},~ p),
$$
where $p$ denotes the probability of a batter not being dismissed in an innings, and
$$
  \log(p / (1- p)) = g(\text{Innings})
$$
We can fit this model using the `mgcv` package.

```{r}
#| label: fig-notouts-gam
#| message: false
#| code-fold: false
#| fig.cap: "Proportion of not outs for each batter as a function of the number of innings they played, with a GAM fit using a Binomial distribution. The blue line shows the probability of a batter being not out as a function of the number of Innings they have played."
fit_notouts <- mgcv::gam(prop_no ~ s(Innings),
  data = df_no,
  family = binomial(link = logit), weights = Innings
)
notouts_aug <- broom::augment(fit_notouts, data = df_no, type.predict = "response")
notouts_aug |>
  ggplot(aes(x = Innings, y = prop_no)) +
  geom_point(alpha = 0.2) +
  geom_line(aes(y = .fitted), color = "#0072B2") +
  geom_ribbon(
    aes(
      ymin = .fitted - 2 * .se.fit,
      ymax = .fitted + 2 * .se.fit
    ),
    fill = "#0072B2", alpha = 0.2
  ) +
  labs(y = "Proportion of not outs")
```

Now we can use the fitted model to compute the surprisals from the Binomial distribution, and find the most anomalous batters. Unfortunately, there is not a convenient way to compute LOO surprisals for GAM models, so we will only consider regular surprisals in this example. While the Binomial distribution is probably a good first approximation, it does assume that the probability of a batter being dismissed does not change over their career, which is an unlikely assumption as it does not allow for the development of skill, the value of experience, or the effect of ageing. So we will use the GPD approximation to compute the surprisal probabilities.

```{r}
#| code-fold: false
#| warning: false
notouts_aug <- notouts_aug |>
  mutate(
    surprisals = surprisals(fit_notouts),
    prob = surprisals_prob(fit_notouts, approximation = "gpd")
  ) |>
  select(Player:Country, Innings:NotOuts, prop_no:.fitted, surprisals:prob) |>
  arrange(desc(surprisals))
notouts_aug
```

The most anomalous batters are all "tail-enders" (i.e., not skilled batters) who played for a long time (so they have a large number of innings). Because they batted last, or nearly last, they are more likely to be not out at the end of the team's innings.

The `.fitted` value is the expected proportion of not outs for each player given the number of innings they have played, while `prop_no` gives the actual proportion of not outs they have had. The largest surprisal is for English batter Jimmy Anderson, who has had `r notouts_aug$NotOuts[1]` not outs in `r notouts_aug$Innings[1]` innings, which is much higher than the expected number of not outs of $`r notouts_aug[["Innings"]][1]` \times `r sprintf("%.3f", notouts_aug[[".fitted"]][1])` = `r sprintf("%.1f", notouts_aug[[".fitted"]][1]*notouts_aug[["Innings"]][1])`$. This anomaly is also seen in @fig-notouts-gam, as being somewhat unusual for that part of the data. Although Jimmy Anderson was not a great batter, he was good at defence, and was able to bat for a long time without being dismissed, leaving the other batter time to score runs.

We have identified an anomaly that is not anomalous in the proportion of not-outs, or in the number of innings, and the difference between the actual proportion and the predicted proportion is not anomalous either compared to some of the other values. However, because we have used a statistical model, we have been able to account for the particular features of this data set, such as the discrete nature of the data, and the changing variance, to identify an observation that is anomalous in the context of the model.


## KDE surprisals {#sec-kdescores}

Suppose, instead of a regression or a GAM, we estimate $f$ using a kernel density estimate. In fact, when the `surprisals()` functions is applied to data without specifying a probability distribution, a kernel density estimate of the data is used by default. The kernel density estimate at each observation is (@eq-mkde)
$$
  f_i = \hat{f}(\bm{y}_i) = \frac{1}{n} \sum_{j=1}^n K_H(\bm{y}_i-\bm{y}_j),
$$ {#eq-kdescores}
and so the "**kde surprisal**" at each observation as
$$
  p_i = -\log(f_i).
$$
The largest possible surprisal occurs when an observation has no other observations nearby. Then $f_i \approx K_H(\bm{0})/n$ because $K_H(\bm{y}_i-\bm{y}_j)\approx 0$ when $\|\bm{y}_i-\bm{y}_j\|$ is large. So the largest possible kde surprisal, when using a Gaussian kernel, is
$$
  -\log(K_H(\bm{0})/n) \approx \log(n) + \frac{m}{2}\log(2\pi) + \frac{1}{2}\text{log det}(\bm{H}),
$$
where $\bm{H}$ is now the bandwidth matrix. For univariate data, when $m=1$, this simplifies to
$$
  -\log(K_h(0)/n) \approx \log(nh\sqrt{2\pi}).
$$

### Leave-one-out kde surprisals

The contribution of the $i$th point to the kernel density estimate at that point is $K_H(\bm{0})/n$. Therefore, we can compute leave-one-out kde surprisals as
$$
  f_{-i} = \left[nf_i - K_H(\bm{0})\right]/(n-1),
$$ {#eq-lookkde}
where $f_i$ is the kde estimate at $\bm{y}_i$ using all data. Thus, we can compute the leave-one-out kernel surprisals without needing to re-estimate the density many times.

The largest possible LOO kde surprisal is infinite, occuring when there are no observations nearby, so that $nf_i = K_H(\bm{0})$.

### The lookout algorithm {#sec-lookout}

The **"lookout" algorithm** (standing for Leave-One-Out Kernel density estimates for OUTlier detection) was proposed by @lookout, and later modified by @lookout2. It uses surprisal probabilities based on a GPD approximation. Probabilities obtained using this algorithm can be calculated using the `surprisals_prob()` function applied to a data set with `loo = TRUE`, and `approximation = "gdp"`.

### Example: Old Faithful eruption durations

For the Old Faithful eruption duration data, we obtain the following results.

```{r}
#| label: ofscores
#| code-fold: false
of_surprisals <- oldfaithful |>
  mutate(
    loo_kde_surprisal = surprisals(duration, loo = TRUE),
    prob = surprisals_prob(duration, loo = TRUE, approximation = "gpd"),
  )
of_surprisals |> arrange(desc(loo_kde_surprisal))
```

The two infinite LOO surprisals correspond to ????. These are so improbable given the rest of the data, that the scores are effectively infinite. The `prob` column contains the LOO surprisal probabilities based on the KDE.

If we omit the three extreme values, we obtain different results.

```{r}
#| label: ofscores2
#| code-fold: false
of_surprisals <- oldfaithful |>
  filter(duration > 60) |>
  mutate(
    loo_kde_surprisal = surprisals(duration, loo = TRUE),
    prob = surprisals_prob(duration, loo = TRUE, approximation = "gpd"),
  )
of_surprisals |> arrange(desc(loo_kde_surprisal))
```

Now there are five points with probabilities less than 0.005, two at 155, and three above 300.

@fig-ofpot shows an HDR boxplot of the data (other than the maximum), with those points with surprisal probabilities less than 0.005 highlighted in black.

```{r}
#| label: fig-ofpot
#| fig.cap: "HDR boxplot of the Old Faithful eruption durations, with the surprisal anomalies highlighted in black."
#| dependson: ofpot2
#| fig.asp: 0.2
#| code-fold: false
oldfaithful |>
  filter(duration > 1) |>
  gg_hdrboxplot(duration)
```

The same algorithm is easily applied in two dimensions. For example, we can consider the bivariate distribution of Duration and Waiting time.

```{r}
#| label: lookout2
#| code-fold: false
of <- oldfaithful |>
  select(duration, waiting) 
of |>
  mutate(
    loo_scores = surprisals(of, loo = TRUE),
    prob = surprisals_prob(of, loo = TRUE, approximation = "gpd")
  ) |>
  filter(prob < 0.005) |>
  arrange(prob, duration)
```

Now, `r english::words(sum(surprisals_prob(of, loo = TRUE, approximation = "gpd") < 0.001))` anomalies are identified, with both of them having infinite LOO surprisals. We can visualize them in an HDR scatterplot, shown in @fig-ofpot2.

```{r}
#| label: fig-ofpot2
#| code-fold: false
#| fig.cap: "HDR scatterplot of the Old Faithful eruption durations and waiting times, with the surprisal anomalies highlighted in black."
of |>
  gg_hdrboxplot(duration, waiting, scatterplot = TRUE)
```

### More examples

Let's apply the kde surprisals method to the six examples introduced in @sec-examples. For this purpose we will use a threshold of 0.001 for the surprisal probabilities.

```{r}
#| label: cricket-lookout
#| code-fold: false
cricket_batting |>
  filter(Innings > 20) |>
  mutate(prob = surprisals_prob(Average, loo = TRUE, approximation = "gpd")) |>
  filter(prob < 0.001) |>
  select(Player, Average, prob)
```

Here Bradman is a clear anomaly (with a very low surprisal probability), and no-one else is identified as a possible anomaly.

Next we consider some artificial examples. First, we consider the first 48 rows of the second variable in the `n01` data, along with the values 4.0 and 4.5.

```{r}
#| label: lookout3
#| code-fold: false
n01b <- tibble(y = c(n01$v2[1:48], 4, 4.5))
n01b |>
  mutate(prob = surprisals_prob(y, loo = TRUE, approximation = "gpd")) |>
  filter(prob < 0.05) |>
  arrange(prob)
```

As expected, only the two genuine anomalies have been identified.

Finally, we consider 1000 simulated observations from each of the distributions, N(0,1), $\text{t}_3$ and $\chi^2_4$.

```{r}
#| label: lookout4
#| code-fold: false
n01 |>
  select(v1) |>
  mutate(prob = surprisals_prob(v1, loo = TRUE, approximation = "gpd")) |>
  filter(prob < 0.001) |>
  arrange(prob, v1)
set.seed(1)
tibble(y = rt(1000, df = 3)) |>
  mutate(prob = surprisals_prob(y, loo = TRUE, approximation = "gpd")) |>
  filter(prob < 0.001) |>
  arrange(prob, y)
tibble(y = rchisq(1000, df = 4)) |>
  mutate(prob = surprisals_prob(y, loo = TRUE, approximation = "gpd")) |>
  filter(prob < 0.001) |>
  arrange(prob, y)
```

The algorithm has found a few spurious anomalies in each case, out of the 1000 observations included. Notably, the results do not appear to deteriorate with the heavier-tailed or skewed distributions.

## Other density-based methods
